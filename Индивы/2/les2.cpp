#include <iostream>



int b = 8;





//Оператор & (узнать адрес переменной)

int main() 
{
    int a = 7;
    std::cout << a << '\n'; // выводим значение переменной a
    std::cout << &a << '\n'; // выводим адрес переменной a
    return 0;
}







//Оператор * (разыменование)

int main() 
{
    int a = 7;
    std::cout << a << '\n';    // значение a
    std::cout << &a << '\n';   // адрес переменной a
    std::cout << *&a << '\n';  // значение по адресу, куда указывает &a (то есть снова a)
    return 0;
}








//УКАЗАТЕЛЬ
//ptr содержит адрес значения переменной value

int main() 
{

    int value = 5;
    int *ptr = &value; // ptr хранит адрес value

    std::cout << *ptr; // выводит значение по адресу ptr (то есть 5)
}







int* iPtr3, iPtr4; 
// iPtr3 - это указатель на значение типа int, 
//а iPtr4 - это обычная переменная типа int!


int *iPtr; // указатель на значение типа int
double *dPtr; // указатель на значение типа double
 
int* iPtr3; // корректный синтаксис (допустимый, но не желательный)
int * iPtr4; // корректный синтаксис (не делайте так)
 
int *iPtr5, *iPtr6; // объявляем два указателя для переменных типа int








//Тип указателя говорит, что именно хранится по адресу

int main() 
{
    int iValue = 7;
    double dValue = 9.0;

    int *iPtr = &iValue;    // ок
    double *dPtr = &dValue; // ок
    // iPtr = &dValue;      // ошибка
}



//&value — это оператор, который возвращает адрес переменной value.
//ptr — это указатель, переменная, которая хранит адрес переменной value


//какой результат ?
int main()
{
    int value = 5;
    int *ptr = &value; // инициализируем ptr адресом значения переменной
 
    std::cout << &value << '\n'; // выводим адрес значения переменной value
    std::cout << ptr << '\n'; // выводим адрес, который хранит ptr
 
    return 0;
}

//Вывод &value
//&value — это адрес переменной value в памяти. 
//Оператор & получает адрес переменной value


//Вывод ptr
//Здесь ptr также указывает на адрес value, 
//потому что мы присвоили этот адрес указателю ptr в строке int *ptr = &value;. 


//ptr содержит тот же адрес, что и &value


//&value каждый раз вычисляет адрес переменной value.
//ptr хранит этот адрес, и его можно использовать позже без повторного вычисления.



//Разыменование указателей

int main()
{
	int value = 5;
	std::cout << &value << std::endl; // выводим адрес value
	std::cout << value << std::endl; // выводим содержимое value
 
	int *ptr = &value; // ptr указывает на value
	std::cout << ptr << std::endl; // выводим адрес, который хранится в ptr, т.е. &value
	std::cout << *ptr << std::endl; // разыменовываем ptr (получаем значение на которое указывает ptr)
 
	return 0;
}

//почему указатели должны иметь тип данных
//Без типа указатель не знал бы, как интерпретировать содержимое






int main()
{
    int value = 5;
    int *ptr = &value; // ptr указывает на value
    
    *ptr = 7; // *ptr - это то же самое, что и value, которому мы присвоили значение 7
    std::cout << value; // выведется 7
}

//*ptr — это операция разыменования указателя ptr
//обращаемся к значению переменной, на которую он указывает. 

//*ptr = 7;, это означает, что мы присваиваем значение 7 переменной value, 
//потому что ptr указывает на value







//Резмеры указателей
int main()
{
    char *chPtr; // тип char занимает 1 байт
    int *iPtr; // тип int занимает 4 байта
    
    std::cout << sizeof(chPtr) << '\n'; // выведется 4 или 8
    std::cout << sizeof(iPtr) << '\n'; // выведется 4 или 8
}





/*
задание 1
Инициализация указателей и получение адреса переменной:

Напишите программу, которая создает переменную типа double, 
присваивает ей значение, и создает указатель на эту переменную. 
Выведите на экран:
Значение переменной.
Адрес переменной с помощью оператора &.
Адрес, хранящийся в указателе.
*/


/*
Задание 2
Работа с разыменованием указателя:

Напишите программу, которая создает переменную типа int и инициализирует ее значением 10. 
Создайте указатель на эту переменную и с помощью разыменования (*) измените значение переменной через указатель на 15. 
Выведите новое значение переменной.
Объясните, почему изменение через разыменование указателя повлияло на значение переменной.
*/



/*
Задание 3
Работа с указателями разных типов:

Создайте две переменные: float и char. 
Затем создайте указатели для обеих переменных, присвойте им адреса этих переменных 
и выведите значения через разыменование указателей.
Попробуйте присвоить указателю типа int адрес переменной типа float. Объясните, почему это вызывает ошибку.
*/


/*
Заданиу 4
Размер указателя:

Напишите программу, которая создает указатели типа char, int, и double. 
Используйте sizeof для вывода их размеров на экран. 
Объясните, почему размеры выводятся именно так
*/



/*
Задание 5
Использование указателя и оператора &:

Напишите программу, которая создает переменную типа int, 
инициализирует её значением 20, и создает указатель на эту переменную.
Выведите адрес переменной через &value и через указатель ptr. 
Объясните, результаты вывода.
*/


/*
Задание 6
Изменение значения переменной через указатель:

Напишите программу, которая создает переменную int value = 5; 
и указатель на нее ptr. 
Измените значение value на 10 через разыменование указателя (*ptr = 10;) 
и выведите новое значение переменной.
Попробуйте присвоить указателю ptr другое значение, 
используя разыменование, например *ptr = 20;. 
Объясните, как это работает.
*/



/*
Задание 7
Понимание типов данных указателей:

Напишите программу, которая создает переменную int, 
затем указатель на int, который указывает на эту переменную.
Объясните, почему указатели должны иметь тип данных, 
и что бы произошло, если бы типы указателя и переменной не совпадали
*/








//1

int main() 
{
    double var = 10.5;
    double* ptr = &var;

    std::cout << "Значение переменной var: " << var << '\n';
    std::cout << "Адрес переменной var (через &): " << &var << '\n';
    std::cout << "Адрес, хранящийся в указателе ptr: " << ptr << '\n';

    return 0;
}



//2
int main() 
{
    int a = 10;
    int* ptr = &a;

    *ptr = 15; // Изменяем значение переменной a через указатель

    std::cout << "Новое значение переменной a: " << a << '\n';

    return 0;
}




//3
int main() 
{
    float f = 3.14f;
    char c = 'A';

    float* fPtr = &f;
    char* cPtr = &c;

    std::cout << "Значение переменной f через указатель: " << *fPtr << '\n';
    std::cout << "Значение переменной c через указатель: " << *cPtr << '\n';

    // Попытка присвоить указателю `int*` адрес `float` (раскомментировать для проверки ошибки)
    // int* intPtr = &f; // Ошибка: указатель типа `int*` не может указывать на `float`

    return 0;
}




//4
int main() 
{
    char* chPtr;
    int* iPtr;
    double* dPtr;

    std::cout << "Размер указателя типа char*: " << sizeof(chPtr) << " байт\n";
    std::cout << "Размер указателя типа int*: " << sizeof(iPtr) << " байт\n";
    std::cout << "Размер указателя типа double*: " << sizeof(dPtr) << " байт\n";

    return 0;
}



//5
int main() 
{
    int value = 20;
    int* ptr = &value;

    std::cout << "Адрес переменной value через &value: " << &value << '\n';
    std::cout << "Адрес, хранящийся в указателе ptr: " << ptr << '\n';

    // Создаем новый указатель и присваиваем ему адрес ptr
    int* newPtr = ptr;

    std::cout << "Адрес через указатель newPtr: " << newPtr << '\n';
    std::cout << "Значение через разыменование *newPtr: " << *newPtr << '\n';

    return 0;
}




//6
int main() 
{
    int value = 5;
    int* ptr = &value;

    *ptr = 10; // Изменяем значение переменной value через указатель

    std::cout << "Новое значение переменной value: " << value << '\n';

    *ptr = 20; // Еще раз изменяем значение через разыменование указателя
    std::cout << "Новое значение переменной value после второго изменения: " << value << '\n';

    return 0;
}




//7
int main() 
{
    int iVar = 42;
    int* iPtr = &iVar;

    std::cout << "Значение переменной iVar через разыменование iPtr: " << *iPtr << '\n';

    // Объяснение: указатель должен иметь тип данных, соответствующий переменной, на которую он указывает
    // int* iPtr не может указывать на переменную типа double, так как это вызовет ошибку.

    return 0;
}


















//НУДЕВОЙ УКАЗАТЕЛЬ


int *ptr = nullptr; 
// указатель на целое число, но он не указывает на никакую переменную



//проверка не нулевой ли указатель
int main() 
{
    int *ptr = nullptr;  // указатель не указывает на ничего

    if (ptr)  // если ptr не равен nullptr
        std::cout << "ptr указывает на переменную.\n";
    else
        std::cout << "ptr — это нулевой указатель.\n";  // этот блок выполнится
    return 0;
}




//Разыменование нулевого указателя
int main() 
{
    int *ptr = nullptr;
    std::cout << *ptr;  // ошибка: разыменование нулевого указателя




    int *ptr = 0;   // старый способ (может быть не очень понятно)
    int *ptr2 = nullptr;  // новый, более ясный способ

}



// тип данных std::nullptr_t

#include <cstddef>  // для std::nullptr_t

void doAnything(std::nullptr_t ptr) 
{
    std::cout << "Вы передали нулевой указатель!\n";
}

int main() 
{
    doAnything(nullptr);  // передаем nullptr как аргумент
    return 0;
}















//Массивы и указатели, сходство



int array[4] = { 5, 8, 6, 4 }; // массив из 4 целых чисел

//что будет если вывести просто array ?




int main()
{
    int array[4] = { 5, 8, 6, 4 };

    // Выводим значение массива (адрес)
    std::cout << "The array has address: " << array << '\n';

    // Выводим адрес первого элемента массива
    std::cout << "Element 0 has address: " << &array[0] << '\n';

    return 0;
}


//что массив и указатель на его первый элемент — 
//это фактически одно и то же в плане адреса



//Разыменование массива
int main()
{
    int array[4] = { 5, 8, 6, 4 };
    std::cout << *array;  // что выведеться ?
}




//передача массива в функцию

void printSize(int *array)
{
    std::cout << sizeof(array) << '\n'; // выведется размер указателя, а не массива!
}

int main()
{
    int array[] = { 1, 2, 3, 4, 5 };
    std::cout << sizeof(array) << '\n'; // выведется размер массива

    printSize(array); // массив распадается в указатель
    return 0;
}

//При передаче массива в функцию, его размер в sizeof(array) 
//внутри функции будет всегда размером указателя, а не массива.

//результат
//20
//4

//следующие два объявления функции идентичны:
void printSize(int array[]);
void printSize(int *array);






//Передача массивов в функции
//синтаксис указателя является более прямым и читаемым. 
//int array[] или int *array

   
void changeArray(int *ptr)
{
    *ptr = 5; // изменим первый элемент массива
}
   
int main()
{
    int array[] = { 1, 2, 3, 4, 5 };
    std::cout << "Element 0 has value: " << array[0] << '\n';
   
    changeArray(array); // изменим элемент
    std::cout << "Element 0 has value: " << array[0] << '\n';
   
    return 0;
}











//Различия между указателями и массивами


//Оператор sizeof
int main()
{
    int array[4] = { 5, 8, 6, 4 };
    std::cout << sizeof(array) << '\n'; // Размер массива (4 * sizeof(int))

    int *ptr = array;
    std::cout << sizeof(ptr) << '\n'; // Размер указателя
    return 0;
}
//какие результаты?
//массив хранит информацию о своей длине, а указатель — только адрес







/*
Задание 1
Массивы и указатели
Напишите программу, которая создает массив из 5 целых чисел. Программа должна вывести:

Адрес самого массива.
Адрес первого элемента массива.
*/

/*
Задание 2
Напишите программу, которая разыменовывает массив 
(используя указатель на первый элемент) и выводит значение первого элемента массива.
*/



/*
Задание 3
Передача массива в функцию

Напишите функцию, которая принимает массив и выводит его размер с помощью оператора sizeof. 
Важно, чтобы программа не выводила размер массива в функции, а только размер указателя.
*/


/*
Задание 4
Напишите программу, которая передает массив в функцию, 
выводит его размер в главной функции и в функции-параметре. 
Объяснить почему выводятся такие результаты размера
*/




/*
Задание 5
Изменение элементов массива в функции

Напишите функцию, которая изменяет первый элемент массива на значение 100. 
Используйте указатель для изменения данных.
*/



/*
Задание 6
Напишите функцию, которая принимает массив и изменяет все его элементы на 0.
*/



/*
Задание 7
Работа с указателями в функциях

Напишите функцию, которая принимает массив и выводит его элементы на экран, используя указатель.
*/


/*
Задание 8
Напишите программу, которая создает массив из 5 чисел, 
передает его в функцию, и в этой функции увеличивает каждый элемент массива на 1
*/


/*
Задание 9
Разыменование указателей
Напишите программу, которая разыменовывает указатель на первый элемент массива и выводит его значение.
*/


/*
Задание 10
Напишите программу, которая разыменовывает указатель на последний элемент массива и выводит его значение.
*/




//1
int main() 
{
    int array[5] = {1, 2, 3, 4, 5};

    std::cout << "Адрес массива: " << array << '\n';  // Адрес массива (как указатель на первый элемент)
    std::cout << "Адрес первого элемента массива: " << &array[0] << '\n';  // Адрес первого элемента

    return 0;
}


//2
int main() 
{
    int array[5] = {1, 2, 3, 4, 5};
    int* ptr = array;  // Указатель на первый элемент массива

    std::cout << "Первый элемент массива: " << *ptr << '\n';  // Разыменовывание указателя

    return 0;
}



//3
void printSize(int* array) 
{
    std::cout << "Размер указателя: " << sizeof(array) << '\n';  // Размер указателя на массив
}

int main() 
{
    int array[5] = {1, 2, 3, 4, 5};
    std::cout << "Размер массива: " << sizeof(array) << '\n';  // Размер массива в главной функции

    printSize(array);  // Передача массива в функцию
    return 0;
}



//4
void printSize(int* array) 
{
    std::cout << "Размер указателя: " << sizeof(array) << '\n';  // Размер указателя на массив
}

int main() 
{
    int array[5] = {1, 2, 3, 4, 5};
    std::cout << "Размер массива в главной функции: " << sizeof(array) << '\n';  // Размер массива в главной функции

    printSize(array);  // Передача массива в функцию
    return 0;
}



//5
void changeArray(int* array) 
{
    array[0] = 100;  // Изменение первого элемента массива
}

int main() 
{
    int array[5] = {1, 2, 3, 4, 5};
    std::cout << "Первый элемент до изменения: " << array[0] << '\n';

    changeArray(array);  // Изменение массива через указатель

    std::cout << "Первый элемент после изменения: " << array[0] << '\n';

    return 0;
}



//6
void zeroArray(int* array, int size) 
{
    for (int i = 0; i < size; ++i) 
    {
        array[i] = 0;  // Присваиваем 0 всем элементам массива
    }
}

int main() 
{
    int array[5] = {1, 2, 3, 4, 5};
    zeroArray(array, 5);  // Передаем массив в функцию для изменения

    // Выводим измененный массив
    for (int i = 0; i < 5; ++i) 
    {
        std::cout << array[i] << ' ';
    }

    return 0;
}



//7
void printArray(int* array, int size) 
{
    for (int i = 0; i < size; ++i) 
    {
        std::cout << *(array + i) << ' ';  // Разыменовывание указателя для доступа к элементу
    }
    std::cout << '\n';
}

int main() 
{
    int array[5] = {1, 2, 3, 4, 5};
    printArray(array, 5);  // Передаем массив в функцию для вывода элементов

    return 0;
}



//8
#include <iostream>

void incrementArray(int* array, int size) 
{
    for (int i = 0; i < size; ++i) 
    {
        array[i] += 1;  // Увеличиваем каждый элемент на 1
    }
}

int main() 
{
    int array[5] = {1, 2, 3, 4, 5};
    incrementArray(array, 5);  // Передаем массив в функцию для увеличения элементов

    // Выводим измененный массив
    for (int i = 0; i < 5; ++i) 
    {
        std::cout << array[i] << ' ';
    }

    return 0;
}



//9
int main() 
{
    int array[5] = {1, 2, 3, 4, 5};
    int* ptr = array;  // Указатель на первый элемент массива

    std::cout << "Значение первого элемента массива: " << *ptr << '\n';  // Разыменовываем указатель

    return 0;
}



//10
int main() 
{
    int array[5] = {1, 2, 3, 4, 5};
    int* ptr = &array[4];  // Указатель на последний элемент массива

    std::cout << "Значение последнего элемента массива: " << *ptr << '\n';  // Разыменовываем указатель

    return 0;
}















//Адресная арифметика 


//int
int main()
{
    int value = 8;
    int *ptr = &value;
 
    std::cout << ptr << '\n';
    std::cout << ptr + 1 << '\n';
    std::cout << ptr + 2 << '\n';
    std::cout << ptr + 3 << '\n';
 
    return 0;
}



//short
int main()
{
    short value = 8;
    short *ptr = &value;
 
    std::cout << ptr << '\n';
    std::cout << ptr + 1 << '\n';
    std::cout << ptr + 2 << '\n';
    std::cout << ptr + 3 << '\n';
 
    return 0;
}






//Расположение элементов массива в памяти
 
int main()
{
    int array[] = {7, 8, 2, 4, 5};
 
    std::cout << "Element 0 is at address: " << &array[0] << '\n';
    std::cout << "Element 1 is at address: " << &array[1] << '\n';
    std::cout << "Element 2 is at address: " << &array[2] << '\n';
    std::cout << "Element 3 is at address: " << &array[3] << '\n';
 
    return 0;
}


//Индексация массивов 
int main()
{
     int array [5] = {7, 8, 2, 4, 5};
 
     std::cout << &array[1] << '\n'; // выведется адрес памяти элемента под индексом 1
     std::cout << array+1 << '\n'; // выведется адрес памяти указателя на массив + 1 
     std::cout << array[1] << '\n'; // выведется 8
     std::cout << *(array+1) << '\n'; // выведется 8
 
    return 0;
}




//Использование указателей для итерации по массиву

int main()
{
    const int arrayLength = 9;
    char name[arrayLength] = "Jonathan";
    int numVowels(0);
    
    for (char *ptr = name; ptr < name + arrayLength; ++ptr)
    {
        switch (*ptr)
        {
        case 'A':
        case 'a':
        case 'E':
        case 'e':
        case 'I':
        case 'i':
        case 'O':
        case 'o':
        case 'U':
        case 'u':
            ++numVowels;
        }
    }

    std::cout << name << " has " << numVowels << " vowels.\n";
    return 0;
}






/*
Задание 1
Адресная арифметика с типом int

Напишите программу, которая создаст переменную типа int, присвоит ей значение 42, 
и выведет на экран:
Адрес этой переменной.
Адрес переменной после увеличения указателя на 1.
Адрес переменной после увеличения указателя на 2 и 3.
*/


/*
Задание 2
Расположение элементов массива в памяти

Напишите программу, которая создает массив из 5 целых чисел и выводит на экран:
Адрес каждого элемента массива (с помощью оператора &).
*/


/*
Задание 3
Индексация массивов через указатели

Напишите программу, которая создает массив из 5 целых чисел. Затем выведите:
Адрес второго элемента массива с использованием &array[1].
Адрес второго элемента с использованием array + 1.
Значение второго элемента с использованием индексации массива array[1].
Значение второго элемента с использованием арифметики указателя *(array + 1).
*/


/*
Задание 4
Использование указателей для итерации по массиву

Напишите программу, которая создает строку (массив символов) 
и подсчитывает количество гласных в строке с помощью указателей. 
Используйте цикл, который будет проходить по всем символам строки, и увеличивайте счетчик, 
если символ является гласной (буква A, E, I, O, U в любом регистре).
*/






//1
int main() 
{
    int value = 42;
    int *ptr = &value;

    std::cout << "Address of value: " << ptr << '\n';
    std::cout << "Address after ptr + 1: " << ptr + 1 << '\n';
    std::cout << "Address after ptr + 2: " << ptr + 2 << '\n';
    std::cout << "Address after ptr + 3: " << ptr + 3 << '\n';

    return 0;
}


//2
int main() 
{
    int array[] = {10, 20, 30, 40, 50};

    std::cout << "Address of element 0: " << &array[0] << '\n';
    std::cout << "Address of element 1: " << &array[1] << '\n';
    std::cout << "Address of element 2: " << &array[2] << '\n';
    std::cout << "Address of element 3: " << &array[3] << '\n';
    std::cout << "Address of element 4: " << &array[4] << '\n';

    return 0;
}


//3
int main() 
{
    int array[5] = {7, 8, 2, 4, 5};

    std::cout << "Address of element 1 (using &array[1]): " << &array[1] << '\n';
    std::cout << "Address of element 1 (using array + 1): " << array + 1 << '\n';
    std::cout << "Value of element 1 (using array[1]): " << array[1] << '\n';
    std::cout << "Value of element 1 (using *(array + 1)): " << *(array + 1) << '\n';

    return 0;
}


//4
int main() 
{
    const int arrayLength = 9;
    char name[arrayLength] = "Jonathan";
    int numVowels = 0;

    for (char *ptr = name; *ptr != '\0'; ++ptr) {
        switch (*ptr) 
        {
            case 'A':
            case 'a':
            case 'E':
            case 'e':
            case 'I':
            case 'i':
            case 'O':
            case 'o':
            case 'U':
            case 'u':
                ++numVowels;
                break;
        }
    }

    std::cout << name << " has " << numVowels << " vowels.\n";
    return 0;
}
